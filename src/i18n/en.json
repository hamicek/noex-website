{
  "meta": {
    "title": "noex - Erlang/OTP Patterns for Node.js",
    "description": "Build fault-tolerant, scalable systems with TypeScript using battle-tested Erlang/OTP patterns"
  },
  "nav": {
    "features": "Features",
    "docs": "Docs",
    "playground": "Playground",
    "github": "GitHub",
    "hero": "Home",
    "problem": "Why noex",
    "services": "Services",
    "observability": "Observability",
    "distribution": "Distribution",
    "cta": "Get Started",
    "store": "Store",
    "rules": "Rules",
    "openMenu": "Open menu",
    "closeMenu": "Close menu"
  },
  "hero": {
    "headline": "Erlang/OTP Patterns for Node.js",
    "subheadline": "Build fault-tolerant, scalable systems with TypeScript",
    "cta": {
      "getStarted": "Get Started",
      "viewGithub": "View on GitHub"
    },
    "scrollDown": "Scroll to explore"
  },
  "whyNoex": {
    "tagline": "Inspired by 40+ years of Erlang/OTP",
    "title": "Why noex?",
    "subtitle": "Node.js is fast and flexible, but building reliable distributed systems requires proven patterns. noex brings battle-tested Erlang/OTP concepts to TypeScript, so you can focus on your business logic instead of infrastructure.",
    "benefits": {
      "proven": {
        "title": "Battle-tested patterns",
        "description": "GenServer, Supervisor, Registry - concepts that power WhatsApp, Discord, and millions of telecom systems worldwide. Now available in your TypeScript codebase."
      },
      "faultTolerant": {
        "title": "Fault-tolerant by design",
        "description": "Embrace the 'let it crash' philosophy. Processes fail gracefully and supervisors automatically restart them. No more cascading failures bringing down your entire app."
      },
      "distributed": {
        "title": "Distributed from day one",
        "description": "The same code that runs on one machine scales across a cluster. Location-transparent messaging means you don't rewrite anything when you need to scale."
      },
      "observable": {
        "title": "Observable out of the box",
        "description": "Built-in web dashboard and terminal UI show you exactly what's happening. See process states, message throughput, and errors in real-time without any configuration."
      }
    },
    "learnMore": "See what problems noex solves"
  },
  "problem": {
    "title": "Node.js is great, but...",
    "subtitle": "Common challenges that slow down development and cause production issues",
    "solvesThese": "solves these problems",
    "issues": {
      "raceConditions": {
        "title": "Race Conditions",
        "description": "Shared mutable state leads to unpredictable bugs"
      },
      "errorHandling": {
        "title": "Error Cascades",
        "description": "One failure can crash your entire application"
      },
      "scaling": {
        "title": "Scaling Complexity",
        "description": "Distributed systems are hard to get right"
      }
    }
  },
  "features": {
    "title": "Core Concepts",
    "subtitle": "Battle-tested patterns from Erlang/OTP, reimagined for TypeScript",
    "genserver": {
      "title": "GenServer",
      "description": "Stateful processes without race conditions. Sequential message processing guarantees consistency."
    },
    "supervisor": {
      "title": "Supervisor",
      "description": "Automatic restart on failures. Let it crash philosophy with smart recovery strategies."
    },
    "registry": {
      "title": "Registry",
      "description": "Named process lookup. Find processes by name instead of managing references."
    }
  },
  "patterns": {
    "title": "Advanced Patterns",
    "subtitle": "Higher-level abstractions for common concurrency scenarios",
    "genStateMachine": {
      "title": "GenStateMachine",
      "description": "Explicit finite state machines with typed states and transitions. Perfect for workflows and protocols."
    },
    "agent": {
      "title": "Agent",
      "description": "Simple state container when you need just state, not a full process. Functional updates with get/update."
    },
    "task": {
      "title": "Task",
      "description": "Supervised async operations with concurrency control. Run fire-and-forget jobs or await results."
    }
  },
  "application": {
    "title": "Application Framework",
    "subtitle": "Complete lifecycle management for production-ready applications",
    "features": {
      "lifecycle": "Lifecycle Management",
      "signals": "Signal Handling",
      "graceful": "Graceful Shutdown"
    },
    "descriptions": {
      "lifecycle": "Consistent startup sequence with health checks. Start, stop, and monitor your application with a unified API.",
      "signals": "Automatic SIGINT/SIGTERM handling for Docker and Kubernetes. Your processes clean up properly.",
      "graceful": "prepStop hooks give services time to drain. Configurable timeouts prevent hanging shutdowns."
    },
    "badges": {
      "kubernetes": "Kubernetes-ready",
      "docker": "Docker-friendly",
      "production": "Production tested"
    }
  },
  "services": {
    "title": "Built-in Services",
    "subtitle": "Production-ready utilities that work seamlessly with your processes",
    "cache": {
      "title": "Cache",
      "description": "In-memory caching with TTL and automatic cleanup"
    },
    "eventbus": {
      "title": "EventBus",
      "description": "Publish/subscribe messaging between processes"
    },
    "ratelimiter": {
      "title": "RateLimiter",
      "description": "Token bucket rate limiting for APIs and resources"
    },
    "ets": {
      "title": "ETS",
      "description": "Erlang Term Storage - fast in-memory key-value store with pattern matching"
    }
  },
  "observability": {
    "title": "Observability Built-in",
    "subtitle": "Monitor your processes in real-time with zero configuration",
    "features": {
      "dashboard": "Web Dashboard",
      "tui": "Terminal UI",
      "metrics": "Process Metrics",
      "logs": "Structured Logs"
    },
    "descriptions": {
      "dashboard": "Web-based interface for remote monitoring",
      "tui": "Interactive terminal dashboard with keyboard navigation",
      "metrics": "Real-time CPU, memory, and message throughput",
      "logs": "Timestamped events with severity levels"
    },
    "badges": {
      "realtime": "Real-time updates",
      "zeroConfig": "Zero configuration",
      "cluster": "Cluster support"
    },
    "command": "npx @hamicek/noex dashboard"
  },
  "distribution": {
    "title": "Distributed by Design",
    "subtitle": "Scale across machines with location transparency. Your processes work the same whether on one machine or hundreds.",
    "features": {
      "cluster": "P2P Clustering",
      "global": "Global Registry",
      "transparent": "Location Transparency"
    },
    "descriptions": {
      "cluster": "Nodes automatically discover each other using mDNS or seed nodes. No central coordinator required.",
      "global": "Register and find processes across all nodes by name. One API for local and remote processes.",
      "transparent": "Send messages to processes regardless of their physical location. The runtime handles routing."
    },
    "nodeLabels": {
      "local": "Local Node",
      "remote": "Remote Nodes"
    },
    "badges": {
      "autoDiscovery": "Auto-discovery",
      "noSinglePoint": "No single point of failure",
      "seamless": "Seamless failover"
    },
    "codeHint": "Same API for local and remote processes"
  },
  "playground": {
    "title": "Try It Out",
    "subtitle": "Explore real-world examples and see noex in action",
    "examples": {
      "counter": {
        "name": "Counter",
        "description": "Basic stateful process"
      },
      "chat": {
        "name": "Chat Server",
        "description": "Pub/sub messaging"
      },
      "worker": {
        "name": "Worker Pool",
        "description": "Supervised workers"
      },
      "stateMachine": {
        "name": "State Machine",
        "description": "Traffic light FSM"
      }
    },
    "terminal": {
      "title": "Terminal",
      "running": "Running...",
      "output": "Output"
    },
    "actions": {
      "copy": "Copy",
      "copied": "Copied!",
      "run": "Run"
    }
  },
  "cta": {
    "title": "Ready to build resilient systems?",
    "subtitle": "Get started in minutes with a simple npm install",
    "install": "Install with npm",
    "copied": "Copied!",
    "steps": {
      "title": "Quick Start",
      "install": "Install the package",
      "import": "Import and use",
      "run": "Run your process"
    },
    "docs": "Read the Docs",
    "github": "Star on GitHub",
    "links": {
      "examples": "Examples",
      "api": "API Reference",
      "contributing": "Contributing"
    },
    "community": {
      "title": "Join the Community",
      "github": "GitHub Discussions",
      "discord": "Discord Server"
    }
  },
  "footer": {
    "copyright": "2024 noex",
    "madeWith": "Made with"
  },
  "languageSwitcher": {
    "label": "Language",
    "currentLang": "Current language"
  },
  "support": {
    "title": "Support the Project",
    "description": "Love noex? Help us keep building amazing tools",
    "btc": "Bitcoin",
    "btcCopied": "Address copied!"
  },
  "storePage": {
    "meta": {
      "title": "noex-store - Schema-driven Reactive Store for Node.js",
      "description": "In-memory store with schema validation, reactive queries, ACID transactions, and pluggable persistence. Built on noex GenServer primitives."
    },
    "hero": {
      "headline": "Schema-driven Reactive Store",
      "subheadline": "In-memory store with automatic schema validation, Convex-style reactive queries, ACID transactions, and pluggable persistence. Built on noex GenServer primitives for fault-tolerant data management.",
      "install": "npm install @hamicek/noex-store",
      "github": "View on GitHub"
    },
    "features": {
      "title": "Key Features",
      "subtitle": "Everything you need for reactive data management in Node.js",
      "schema": {
        "title": "Schema & Validation",
        "description": "Define typed bucket schemas with constraints, auto-generated fields, unique indexes, and format validators. Records are validated automatically on every write."
      },
      "reactiveQueries": {
        "title": "Reactive Queries",
        "description": "Convex-style dependency tracking re-evaluates queries automatically when underlying data changes. Record-level and bucket-level granularity with deep-equality diffing."
      },
      "transactions": {
        "title": "ACID Transactions",
        "description": "Atomic multi-bucket writes with optimistic locking. Read-your-own-writes within a transaction, automatic rollback on conflict, and events published only after commit."
      },
      "persistence": {
        "title": "Pluggable Persistence",
        "description": "Swap between File, SQLite, or Memory adapters. Debounced batching keeps writes efficient. Per-bucket opt-out for ephemeral data."
      },
      "ttl": {
        "title": "TTL & Size Limits",
        "description": "Per-record TTL with human-readable durations and automatic purging. Max-size eviction removes oldest records when a bucket exceeds capacity."
      },
      "events": {
        "title": "Event System",
        "description": "Wildcard pub/sub on bucket mutations. Subscribe to specific buckets, event types, or all changes with a single pattern. Powers reactive queries and persistence under the hood."
      }
    },
    "architecture": {
      "title": "Supervision Architecture",
      "subtitle": "One GenServer per bucket, supervised with one-for-one strategy. If a bucket crashes, others keep running.",
      "store": "Store",
      "supervisor": "Supervisor (one_for_one)",
      "bucketServer": "BucketServer",
      "queryManager": "QueryManager",
      "eventBus": "EventBus",
      "ttlManager": "TtlManager",
      "persistence": "Persistence",
      "bucketIsolation": "Each bucket runs in its own GenServer — full process isolation, sequential message processing, no race conditions.",
      "reactiveLayer": "QueryManager subscribes to EventBus for change notifications. Persistence debounces writes via EventBus. All coordination is event-driven."
    },
    "codeExamples": {
      "title": "See It in Action",
      "subtitle": "Real code examples showing schema definition, reactive queries, and transactions",
      "tabs": {
        "schema": "Schema & CRUD",
        "queries": "Reactive Queries",
        "transactions": "Transactions"
      }
    },
    "cta": {
      "title": "Start building reactive data layers",
      "subtitle": "Add noex-store to your project in seconds",
      "install": "npm install @hamicek/noex-store",
      "copied": "Copied!",
      "github": "Star on GitHub",
      "docs": "Read the Docs",
      "backToNoex": "Back to noex"
    }
  },
  "rulesPage": {
    "meta": {
      "title": "noex-rules - Rule Engine with Complex Event Processing",
      "description": "Forward chaining rule engine with CEP, three DSL flavors, integrated fact store, and production-ready REST API. Built on noex GenServer actors."
    },
    "hero": {
      "headline": "Rule Engine with Complex Event Processing",
      "subheadline": "Forward chaining engine with temporal pattern detection, three DSL flavors, integrated fact store, and production-ready REST/GraphQL APIs. Built on noex GenServer actors for fault-tolerant rule processing.",
      "install": "npm install @hamicek/noex-rules",
      "github": "View on GitHub"
    },
    "features": {
      "title": "Key Features",
      "subtitle": "Everything you need for production rule processing and event correlation",
      "forwardChaining": {
        "title": "Forward Chaining Engine",
        "description": "Priority-based rule execution with automatic re-evaluation on fact changes, events, and timer expirations. Individual rule failures don't affect the rest of the system."
      },
      "cep": {
        "title": "Complex Event Processing",
        "description": "Built-in temporal patterns: sequence detection, absence monitoring, count thresholds, and numeric aggregations — all with configurable time windows and grouping."
      },
      "dsl": {
        "title": "Three DSL Flavors",
        "description": "Write rules your way: fluent builder API with full TypeScript autocomplete, tagged template literals for compact syntax, or YAML files for configuration-driven workflows."
      },
      "factStore": {
        "title": "Fact Store with Wildcards",
        "description": "In-memory key-value storage with segmented wildcard pattern matching. Version tracking and change notifications power automatic rule re-evaluation."
      },
      "timers": {
        "title": "Timer Management",
        "description": "Declarative timers with human-readable durations. One-shot and repeating schedules, optional persistence, and automatic event emission on expiration."
      },
      "api": {
        "title": "REST API & Web UI",
        "description": "Production-ready Fastify server with Swagger docs, SSE streaming, webhooks, and a React-based admin interface. Manage rules, facts, and events via HTTP."
      }
    },
    "dsl": {
      "title": "Write Rules Your Way",
      "subtitle": "Three DSL flavors for the same rule — pick the one that fits your workflow",
      "tabs": {
        "fluent": "Fluent Builder",
        "template": "Tagged Template",
        "yaml": "YAML"
      }
    },
    "cep": {
      "title": "Complex Event Processing",
      "subtitle": "Detect patterns across event streams with time windows and grouping",
      "sequence": {
        "title": "Sequence",
        "description": "Detect ordered events within a time window with optional strict mode and groupBy."
      },
      "absence": {
        "title": "Absence",
        "description": "Trigger when an expected event does not occur within the time window."
      },
      "count": {
        "title": "Count",
        "description": "Detect when event frequency exceeds a threshold within a sliding or tumbling window."
      },
      "aggregate": {
        "title": "Aggregate",
        "description": "Track numeric aggregations (sum, avg, min, max) over event fields in time windows."
      }
    },
    "useCases": {
      "title": "Real-world Use Cases",
      "subtitle": "From fraud detection to IoT — noex-rules powers event-driven business logic",
      "fraud": {
        "title": "Fraud Detection",
        "description": "Detect suspicious login patterns, unusual transaction amounts, and geographic anomalies in real-time."
      },
      "payment": {
        "title": "Payment Orchestration",
        "description": "Manage payment flows with timeout handling, retry logic, and automatic escalation on failure."
      },
      "loyalty": {
        "title": "Loyalty Programs",
        "description": "Calculate points, track tier upgrades, and trigger rewards based on customer activity patterns."
      },
      "iot": {
        "title": "IoT Event Processing",
        "description": "Monitor sensor data streams, detect threshold breaches, and correlate events across devices."
      }
    },
    "cta": {
      "title": "Start building intelligent event processing",
      "subtitle": "Add noex-rules to your project in seconds",
      "install": "npm install @hamicek/noex-rules",
      "copied": "Copied!",
      "github": "Star on GitHub",
      "docs": "Read the Docs",
      "backToNoex": "Back to noex"
    }
  }
}
