{
  "meta": {
    "title": "noex - Erlang/OTP Patterns for Node.js",
    "description": "Build fault-tolerant, scalable systems with TypeScript using battle-tested Erlang/OTP patterns"
  },
  "nav": {
    "features": "Features",
    "docs": "Docs",
    "playground": "Playground",
    "github": "GitHub",
    "hero": "Home",
    "problem": "Why noex",
    "services": "Services",
    "observability": "Observability",
    "distribution": "Distribution",
    "cta": "Get Started",
    "store": "Store",
    "rules": "Rules",
    "server": "Server",
    "client": "Client",
    "openMenu": "Open menu",
    "closeMenu": "Close menu"
  },
  "hero": {
    "headline": "Erlang/OTP Patterns for Node.js",
    "subheadline": "Build fault-tolerant, scalable systems with TypeScript",
    "cta": {
      "getStarted": "Get Started",
      "viewGithub": "View on GitHub"
    },
    "scrollDown": "Scroll to explore"
  },
  "whyNoex": {
    "tagline": "Inspired by 40+ years of Erlang/OTP",
    "title": "Why noex?",
    "subtitle": "Node.js is fast and flexible, but building reliable distributed systems requires proven patterns. noex brings battle-tested Erlang/OTP concepts to TypeScript, so you can focus on your business logic instead of infrastructure.",
    "benefits": {
      "proven": {
        "title": "Battle-tested patterns",
        "description": "GenServer, Supervisor, Registry - concepts that power WhatsApp, Discord, and millions of telecom systems worldwide. Now available in your TypeScript codebase."
      },
      "faultTolerant": {
        "title": "Fault-tolerant by design",
        "description": "Embrace the 'let it crash' philosophy. Processes fail gracefully and supervisors automatically restart them. No more cascading failures bringing down your entire app."
      },
      "distributed": {
        "title": "Distributed from day one",
        "description": "The same code that runs on one machine scales across a cluster. Location-transparent messaging means you don't rewrite anything when you need to scale."
      },
      "observable": {
        "title": "Observable out of the box",
        "description": "Built-in web dashboard and terminal UI show you exactly what's happening. See process states, message throughput, and errors in real-time without any configuration."
      }
    },
    "learnMore": "See what problems noex solves"
  },
  "problem": {
    "title": "Node.js is great, but...",
    "subtitle": "Common challenges that slow down development and cause production issues",
    "solvesThese": "solves these problems",
    "issues": {
      "raceConditions": {
        "title": "Race Conditions",
        "description": "Shared mutable state leads to unpredictable bugs"
      },
      "errorHandling": {
        "title": "Error Cascades",
        "description": "One failure can crash your entire application"
      },
      "scaling": {
        "title": "Scaling Complexity",
        "description": "Distributed systems are hard to get right"
      }
    }
  },
  "features": {
    "title": "Core Concepts",
    "subtitle": "Battle-tested patterns from Erlang/OTP, reimagined for TypeScript",
    "genserver": {
      "title": "GenServer",
      "description": "Stateful processes without race conditions. Sequential message processing guarantees consistency."
    },
    "supervisor": {
      "title": "Supervisor",
      "description": "Automatic restart on failures. Let it crash philosophy with smart recovery strategies."
    },
    "registry": {
      "title": "Registry",
      "description": "Named process lookup. Find processes by name instead of managing references."
    }
  },
  "patterns": {
    "title": "Advanced Patterns",
    "subtitle": "Higher-level abstractions for common concurrency scenarios",
    "genStateMachine": {
      "title": "GenStateMachine",
      "description": "Explicit finite state machines with typed states and transitions. Perfect for workflows and protocols."
    },
    "agent": {
      "title": "Agent",
      "description": "Simple state container when you need just state, not a full process. Functional updates with get/update."
    },
    "task": {
      "title": "Task",
      "description": "Supervised async operations with concurrency control. Run fire-and-forget jobs or await results."
    }
  },
  "application": {
    "title": "Application Framework",
    "subtitle": "Complete lifecycle management for production-ready applications",
    "features": {
      "lifecycle": "Lifecycle Management",
      "signals": "Signal Handling",
      "graceful": "Graceful Shutdown"
    },
    "descriptions": {
      "lifecycle": "Consistent startup sequence with health checks. Start, stop, and monitor your application with a unified API.",
      "signals": "Automatic SIGINT/SIGTERM handling for Docker and Kubernetes. Your processes clean up properly.",
      "graceful": "prepStop hooks give services time to drain. Configurable timeouts prevent hanging shutdowns."
    },
    "badges": {
      "kubernetes": "Kubernetes-ready",
      "docker": "Docker-friendly",
      "production": "Production tested"
    }
  },
  "services": {
    "title": "Built-in Services",
    "subtitle": "Production-ready utilities that work seamlessly with your processes",
    "cache": {
      "title": "Cache",
      "description": "In-memory caching with TTL and automatic cleanup"
    },
    "eventbus": {
      "title": "EventBus",
      "description": "Publish/subscribe messaging between processes"
    },
    "ratelimiter": {
      "title": "RateLimiter",
      "description": "Token bucket rate limiting for APIs and resources"
    },
    "ets": {
      "title": "ETS",
      "description": "Erlang Term Storage - fast in-memory key-value store with pattern matching"
    }
  },
  "observability": {
    "title": "Observability Built-in",
    "subtitle": "Monitor your processes in real-time with zero configuration",
    "features": {
      "dashboard": "Web Dashboard",
      "tui": "Terminal UI",
      "metrics": "Process Metrics",
      "logs": "Structured Logs"
    },
    "descriptions": {
      "dashboard": "Web-based interface for remote monitoring",
      "tui": "Interactive terminal dashboard with keyboard navigation",
      "metrics": "Real-time CPU, memory, and message throughput",
      "logs": "Timestamped events with severity levels"
    },
    "badges": {
      "realtime": "Real-time updates",
      "zeroConfig": "Zero configuration",
      "cluster": "Cluster support"
    },
    "command": "npx @hamicek/noex dashboard"
  },
  "distribution": {
    "title": "Distributed by Design",
    "subtitle": "Scale across machines with location transparency. Your processes work the same whether on one machine or hundreds.",
    "features": {
      "cluster": "P2P Clustering",
      "global": "Global Registry",
      "transparent": "Location Transparency"
    },
    "descriptions": {
      "cluster": "Nodes automatically discover each other using mDNS or seed nodes. No central coordinator required.",
      "global": "Register and find processes across all nodes by name. One API for local and remote processes.",
      "transparent": "Send messages to processes regardless of their physical location. The runtime handles routing."
    },
    "nodeLabels": {
      "local": "Local Node",
      "remote": "Remote Nodes"
    },
    "badges": {
      "autoDiscovery": "Auto-discovery",
      "noSinglePoint": "No single point of failure",
      "seamless": "Seamless failover"
    },
    "codeHint": "Same API for local and remote processes"
  },
  "playground": {
    "title": "Try It Out",
    "subtitle": "Explore real-world examples and see noex in action",
    "examples": {
      "counter": {
        "name": "Counter",
        "description": "Basic stateful process"
      },
      "chat": {
        "name": "Chat Server",
        "description": "Pub/sub messaging"
      },
      "worker": {
        "name": "Worker Pool",
        "description": "Supervised workers"
      },
      "stateMachine": {
        "name": "State Machine",
        "description": "Traffic light FSM"
      }
    },
    "terminal": {
      "title": "Terminal",
      "running": "Running...",
      "output": "Output"
    },
    "actions": {
      "copy": "Copy",
      "copied": "Copied!",
      "run": "Run"
    }
  },
  "cta": {
    "title": "Ready to build resilient systems?",
    "subtitle": "Get started in minutes with a simple npm install",
    "install": "Install with npm",
    "copied": "Copied!",
    "steps": {
      "title": "Quick Start",
      "install": "Install the package",
      "import": "Import and use",
      "run": "Run your process"
    },
    "docs": "Read the Docs",
    "github": "Star on GitHub",
    "links": {
      "examples": "Examples",
      "api": "API Reference",
      "contributing": "Contributing"
    },
    "community": {
      "title": "Join the Community",
      "github": "GitHub Discussions",
      "discord": "Discord Server"
    }
  },
  "footer": {
    "copyright": "2024 noex",
    "madeWith": "Made with"
  },
  "languageSwitcher": {
    "label": "Language",
    "currentLang": "Current language"
  },
  "support": {
    "title": "Support the Project",
    "description": "Love noex? Help us keep building amazing tools",
    "btc": "Bitcoin",
    "btcCopied": "Address copied!"
  },
  "storePage": {
    "meta": {
      "title": "noex-store - Schema-driven Reactive Store for Node.js",
      "description": "In-memory store with schema validation, reactive queries, ACID transactions, and pluggable persistence. Built on noex GenServer primitives."
    },
    "hero": {
      "headline": "Schema-driven Reactive Store",
      "subheadline": "In-memory store with automatic schema validation, Convex-style reactive queries, ACID transactions, and pluggable persistence. Built on noex GenServer primitives for fault-tolerant data management.",
      "install": "npm install @hamicek/noex-store",
      "github": "View on GitHub"
    },
    "features": {
      "title": "Key Features",
      "subtitle": "Everything you need for reactive data management in Node.js",
      "schema": {
        "title": "Schema & Validation",
        "description": "Define typed bucket schemas with constraints, auto-generated fields, unique indexes, and format validators. Records are validated automatically on every write."
      },
      "reactiveQueries": {
        "title": "Reactive Queries",
        "description": "Convex-style dependency tracking re-evaluates queries automatically when underlying data changes. Record-level and bucket-level granularity with deep-equality diffing."
      },
      "transactions": {
        "title": "ACID Transactions",
        "description": "Atomic multi-bucket writes with optimistic locking. Read-your-own-writes within a transaction, automatic rollback on conflict, and events published only after commit."
      },
      "persistence": {
        "title": "Pluggable Persistence",
        "description": "Swap between File, SQLite, or Memory adapters. Debounced batching keeps writes efficient. Per-bucket opt-out for ephemeral data."
      },
      "ttl": {
        "title": "TTL & Size Limits",
        "description": "Per-record TTL with human-readable durations and automatic purging. Max-size eviction removes oldest records when a bucket exceeds capacity."
      },
      "events": {
        "title": "Event System",
        "description": "Wildcard pub/sub on bucket mutations. Subscribe to specific buckets, event types, or all changes with a single pattern. Powers reactive queries and persistence under the hood."
      }
    },
    "architecture": {
      "title": "Supervision Architecture",
      "subtitle": "One GenServer per bucket, supervised with one-for-one strategy. If a bucket crashes, others keep running.",
      "store": "Store",
      "supervisor": "Supervisor (one_for_one)",
      "bucketServer": "BucketServer",
      "queryManager": "QueryManager",
      "eventBus": "EventBus",
      "ttlManager": "TtlManager",
      "persistence": "Persistence",
      "bucketIsolation": "Each bucket runs in its own GenServer — full process isolation, sequential message processing, no race conditions.",
      "reactiveLayer": "QueryManager subscribes to EventBus for change notifications. Persistence debounces writes via EventBus. All coordination is event-driven."
    },
    "codeExamples": {
      "title": "See It in Action",
      "subtitle": "Real code examples showing schema definition, reactive queries, and transactions",
      "tabs": {
        "schema": "Schema & CRUD",
        "queries": "Reactive Queries",
        "transactions": "Transactions"
      }
    },
    "comparison": {
      "title": "How It Compares",
      "subtitle": "noex-store vs popular reactive stores and client-side databases",
      "noexStore": "noex-store",
      "competitors": ["RxDB", "TinyBase", "SignalDB", "LokiJS", "Dexie.js", "WatermelonDB"],
      "features": [
        {
          "label": "Reactive Queries",
          "noex": "Convex-style",
          "others": ["RxJS Observables", "Query engine", "Signal-based", "DynamicViews", "liveQuery", "observe()"]
        },
        {
          "label": "Schema Validation",
          "noex": "Built-in DSL",
          "others": ["JSON Schema", "Schematizers", "Validate event", "\u2014", "\u2014", "Column types"]
        },
        {
          "label": "Multi-collection Transactions",
          "noex": "Optimistic locking",
          "others": ["\u2014", "Single-store", "\u2014", "Single-coll.", "ACID", "Writer blocks"]
        },
        {
          "label": "Persistence",
          "noex": "Adapter-based",
          "others": ["Swappable storage", "Adapters", "Adapters", "Adapters", "IndexedDB", "SQLite"]
        },
        {
          "label": "TTL / Auto-expiration",
          "noex": "First-class",
          "others": ["Cleanup only", "\u2014", "\u2014", "Buggy", "\u2014", "\u2014"]
        },
        {
          "label": "Event Bus with Wildcards",
          "noex": "Topic pub/sub",
          "others": ["RxJS streams", "Granular listeners", "Collection events", "Collection events", "Hooks", "Observables"]
        },
        {
          "label": "In-memory First",
          "values": [true, false, true, true, true, false, false]
        },
        {
          "label": "Supervision Tree",
          "noex": "OTP one_for_one",
          "others": ["\u2014", "\u2014", "\u2014", "\u2014", "\u2014", "\u2014"]
        },
        {
          "label": "Secondary Indexes",
          "noex": "Unique + non-unique",
          "others": ["JSON Schema", "Indexes API", "Query selectors", "Unique + binary", "Core feature", "isIndexed"]
        },
        {
          "label": "Bundle Size (gzip)",
          "noex": "~5 kB",
          "others": ["60\u2013150+ kB", "3.5\u20138 kB", "~5\u20138 kB", "~20 kB", "~26 kB", "~2 MB"]
        },
        {
          "label": "Status",
          "noex": "Active",
          "others": ["Active (freemium)", "Active", "Active", "Archived", "Active", "Active"]
        }
      ],
      "differentiators": {
        "title": "What Makes noex-store Unique",
        "items": [
          {
            "title": "Supervision Tree",
            "description": "Each bucket is an isolated GenServer actor. If one crashes, the supervisor restarts it while siblings continue unaffected."
          },
          {
            "title": "First-class TTL",
            "description": "Declarative per-bucket expiration with automatic background purge and _expiresAt metadata."
          },
          {
            "title": "Convex-style Reactive Queries",
            "description": "Plain async functions become live subscriptions with automatic bucket-level and record-level dependency tracking."
          },
          {
            "title": "Multi-bucket ACID Transactions",
            "description": "Version-based optimistic locking with atomic commit and best-effort rollback across collections."
          },
          {
            "title": "Wildcard Event Bus",
            "description": "Subscribe to patterns like bucket.*.deleted or bucket.users.* across the entire store."
          }
        ]
      }
    },
    "cta": {
      "title": "Start building reactive data layers",
      "subtitle": "Add noex-store to your project in seconds",
      "install": "npm install @hamicek/noex-store",
      "copied": "Copied!",
      "github": "Star on GitHub",
      "docs": "Read the Docs",
      "backToNoex": "Back to noex"
    }
  },
  "rulesPage": {
    "meta": {
      "title": "noex-rules - Rule Engine with Complex Event Processing",
      "description": "Forward chaining rule engine with CEP, three DSL flavors, integrated fact store, and production-ready REST API. Built on noex GenServer actors."
    },
    "hero": {
      "headline": "Rule Engine with Complex Event Processing",
      "subheadline": "Forward chaining engine with temporal pattern detection, three DSL flavors, integrated fact store, and production-ready REST/GraphQL APIs. Built on noex GenServer actors for fault-tolerant rule processing.",
      "install": "npm install @hamicek/noex-rules",
      "github": "View on GitHub"
    },
    "features": {
      "title": "Key Features",
      "subtitle": "Everything you need for production rule processing and event correlation",
      "forwardChaining": {
        "title": "Forward Chaining Engine",
        "description": "Priority-based rule execution with automatic re-evaluation on fact changes, events, and timer expirations. Individual rule failures don't affect the rest of the system."
      },
      "cep": {
        "title": "Complex Event Processing",
        "description": "Built-in temporal patterns: sequence detection, absence monitoring, count thresholds, and numeric aggregations — all with configurable time windows and grouping."
      },
      "dsl": {
        "title": "Three DSL Flavors",
        "description": "Write rules your way: fluent builder API with full TypeScript autocomplete, tagged template literals for compact syntax, or YAML files for configuration-driven workflows."
      },
      "factStore": {
        "title": "Fact Store with Wildcards",
        "description": "In-memory key-value storage with segmented wildcard pattern matching. Version tracking and change notifications power automatic rule re-evaluation."
      },
      "timers": {
        "title": "Timer Management",
        "description": "Declarative timers with human-readable durations. One-shot and repeating schedules, optional persistence, and automatic event emission on expiration."
      },
      "api": {
        "title": "REST API & Web UI",
        "description": "Production-ready Fastify server with Swagger docs, SSE streaming, webhooks, and a React-based admin interface. Manage rules, facts, and events via HTTP."
      }
    },
    "dsl": {
      "title": "Write Rules Your Way",
      "subtitle": "Three DSL flavors for the same rule — pick the one that fits your workflow",
      "tabs": {
        "fluent": "Fluent Builder",
        "template": "Tagged Template",
        "yaml": "YAML"
      }
    },
    "cep": {
      "title": "Complex Event Processing",
      "subtitle": "Detect patterns across event streams with time windows and grouping",
      "sequence": {
        "title": "Sequence",
        "description": "Detect ordered events within a time window with optional strict mode and groupBy."
      },
      "absence": {
        "title": "Absence",
        "description": "Trigger when an expected event does not occur within the time window."
      },
      "count": {
        "title": "Count",
        "description": "Detect when event frequency exceeds a threshold within a sliding or tumbling window."
      },
      "aggregate": {
        "title": "Aggregate",
        "description": "Track numeric aggregations (sum, avg, min, max) over event fields in time windows."
      }
    },
    "useCases": {
      "title": "Real-world Use Cases",
      "subtitle": "From fraud detection to IoT — noex-rules powers event-driven business logic",
      "fraud": {
        "title": "Fraud Detection",
        "description": "Detect suspicious login patterns, unusual transaction amounts, and geographic anomalies in real-time."
      },
      "payment": {
        "title": "Payment Orchestration",
        "description": "Manage payment flows with timeout handling, retry logic, and automatic escalation on failure."
      },
      "loyalty": {
        "title": "Loyalty Programs",
        "description": "Calculate points, track tier upgrades, and trigger rewards based on customer activity patterns."
      },
      "iot": {
        "title": "IoT Event Processing",
        "description": "Monitor sensor data streams, detect threshold breaches, and correlate events across devices."
      }
    },
    "comparison": {
      "title": "How It Compares",
      "subtitle": "noex-rules vs popular JavaScript rule engines",
      "noexRules": "noex-rules",
      "competitors": ["json-rules-engine", "nools", "node-rules", "rools", "zen-engine"],
      "features": [
        {
          "label": "Forward Chaining",
          "noex": "Yes",
          "others": ["Yes", "Yes (Rete)", "Yes", "Yes", "Decision tables"]
        },
        {
          "label": "CEP / Temporal Patterns",
          "noex": "Sequence, absence, count, aggregate",
          "others": ["\u2014", "\u2014", "\u2014", "\u2014", "\u2014"]
        },
        {
          "label": "DSL",
          "noex": "Fluent + templates",
          "others": ["JSON only", "Custom DSL", "JSON only", "Plain objects", "DMN / FEEL"]
        },
        {
          "label": "YAML Rule Definitions",
          "values": [true, false, false, false, false, false]
        },
        {
          "label": "Fact Store with Pattern Matching",
          "noex": "Built-in wildcards",
          "others": ["Almanac", "Working memory", "\u2014", "\u2014", "\u2014"]
        },
        {
          "label": "Timer Management",
          "noex": "Built-in DSL",
          "others": ["\u2014", "\u2014", "\u2014", "\u2014", "\u2014"]
        },
        {
          "label": "Event Correlation",
          "noex": "Correlation + causation IDs",
          "others": ["\u2014", "\u2014", "\u2014", "\u2014", "\u2014"]
        },
        {
          "label": "Wildcard Event Subscriptions",
          "noex": "Topic patterns",
          "others": ["\u2014", "\u2014", "\u2014", "\u2014", "\u2014"]
        },
        {
          "label": "REST API",
          "noex": "Built-in (Fastify)",
          "others": ["\u2014", "\u2014", "\u2014", "\u2014", "\u2014"]
        },
        {
          "label": "SSE + Webhooks",
          "values": [true, false, false, false, false, false]
        },
        {
          "label": "String Interpolation",
          "noex": "${expression}",
          "others": ["\u2014", "JS in DSL", "\u2014", "\u2014", "FEEL expressions"]
        },
        {
          "label": "External Service Calls",
          "noex": "call_service action",
          "others": ["Custom operators", "Custom functions", "Custom handlers", "\u2014", "Custom nodes"]
        },
        {
          "label": "OTP Supervision",
          "noex": "noex GenServer",
          "others": ["\u2014", "\u2014", "\u2014", "\u2014", "\u2014"]
        },
        {
          "label": "Priority-based Execution",
          "noex": "Yes",
          "others": ["Yes", "Salience", "Yes", "Yes", "Row order"]
        },
        {
          "label": "OpenAPI / Swagger",
          "values": [true, false, false, false, false, false]
        },
        {
          "label": "Status",
          "noex": "Active",
          "others": ["Active", "Archived", "Low activity", "Active", "Active"]
        }
      ],
      "differentiators": {
        "title": "What Makes noex-rules Unique",
        "items": [
          {
            "title": "Complex Event Processing",
            "description": "The only JS rule engine with built-in CEP: sequence detection, absence monitoring, frequency counting, and aggregate thresholds with time windows."
          },
          {
            "title": "Three DSL Flavors",
            "description": "Fluent builder with TypeScript autocomplete, tagged template literals for quick prototyping, and YAML for configuration-driven workflows."
          },
          {
            "title": "Integrated Fact Store",
            "description": "Wildcard pattern queries with automatic rule re-evaluation on fact changes. No separate state management needed."
          },
          {
            "title": "Built-in Timer Management",
            "description": "Declarative timers with human-readable durations, repeat intervals, and automatic event emission on expiry."
          },
          {
            "title": "Production-ready REST API",
            "description": "Fastify-based HTTP layer with SSE streaming, HMAC-signed webhooks, and Swagger documentation out of the box."
          },
          {
            "title": "OTP Supervision",
            "description": "Built on noex GenServer actors. If the engine crashes, the supervisor restarts it while the rest of your application continues."
          }
        ]
      }
    },
    "cta": {
      "title": "Start building intelligent event processing",
      "subtitle": "Add noex-rules to your project in seconds",
      "install": "npm install @hamicek/noex-rules",
      "copied": "Copied!",
      "github": "Star on GitHub",
      "docs": "Read the Docs",
      "backToNoex": "Back to noex"
    }
  },
  "serverPage": {
    "meta": {
      "title": "noex-server - Real-time WebSocket Server for noex Ecosystem",
      "description": "WebSocket server with GenServer per-connection isolation, reactive subscriptions, authentication, rate limiting, and backpressure management. Built on noex primitives."
    },
    "hero": {
      "headline": "Real-time WebSocket Server",
      "subheadline": "JSON-based protocol over WebSocket with GenServer per-connection isolation, reactive store subscriptions, rules engine proxy, pluggable authentication, and built-in backpressure management.",
      "install": "npm install @hamicek/noex-server",
      "github": "View on GitHub"
    },
    "features": {
      "title": "Key Features",
      "subtitle": "Everything you need for real-time WebSocket communication in Node.js",
      "genserver": {
        "title": "GenServer per Connection",
        "description": "Each WebSocket connection runs in its own GenServer actor, supervised with simple_one_for_one strategy. If one connection crashes, others continue unaffected."
      },
      "storeProxy": {
        "title": "Full Store Proxy",
        "description": "Complete CRUD operations, reactive query subscriptions with automatic push updates, cursor-based pagination, aggregations, and multi-bucket ACID transactions over WebSocket."
      },
      "rulesProxy": {
        "title": "Rules Engine Proxy",
        "description": "Event emission, fact management, pattern-based wildcard queries, and real-time event subscriptions — all proxied through the WebSocket connection."
      },
      "auth": {
        "title": "Authentication & Authorization",
        "description": "Pluggable token validation with per-connection sessions. Role-based permission checks on every operation. Session expiration with automatic enforcement."
      },
      "rateLimit": {
        "title": "Rate Limiting",
        "description": "Sliding window rate limiter with configurable max requests and window duration. Per-user for authenticated or per-IP for anonymous connections."
      },
      "heartbeat": {
        "title": "Heartbeat Ping/Pong",
        "description": "Automatic dead connection detection with configurable intervals (default 30s) and timeout (default 10s). Connections closed with code 4001 on timeout."
      },
      "backpressure": {
        "title": "Write-Buffer Backpressure",
        "description": "Protection against slow clients. When WebSocket write buffer exceeds the high water mark (default 80% of 1 MB), push messages are dropped to prevent memory exhaustion."
      },
      "gracefulShutdown": {
        "title": "Graceful Shutdown",
        "description": "Clients receive a system shutdown notification with grace period. New connections rejected while existing clients have time to disconnect cleanly."
      }
    },
    "protocol": {
      "title": "Protocol & Messages",
      "subtitle": "JSON over WebSocket, protocol version 1.0.0. Request-response with async push notifications.",
      "lifecycle": "Connection Lifecycle",
      "lifecycleSteps": {
        "connect": "WebSocket connect",
        "welcome": "Server sends welcome message with protocol version",
        "auth": "Client authenticates (if auth required)",
        "requestResponse": "Client sends requests, server responds",
        "push": "Server pushes subscription updates",
        "disconnect": "Client or server closes connection"
      },
      "messageTypes": {
        "title": "Message Types",
        "request": "Request",
        "response": "Response",
        "push": "Push",
        "heartbeat": "Heartbeat"
      },
      "tabs": {
        "storeOps": "Store Operations",
        "rulesOps": "Rules Operations",
        "authOps": "Auth Operations",
        "serverOps": "Server Operations"
      },
      "storeOps": ["insert", "get", "update", "delete", "all", "where", "findOne", "count", "first", "last", "paginate", "clear", "sum", "avg", "min", "max", "subscribe", "unsubscribe", "transaction", "buckets", "stats"],
      "rulesOps": ["emit", "setFact", "getFact", "deleteFact", "queryFacts", "getAllFacts", "subscribe", "unsubscribe", "stats"],
      "authOps": ["login", "logout", "whoami"],
      "serverOps": ["stats", "connections"]
    },
    "architecture": {
      "title": "Supervision Architecture",
      "subtitle": "GenServer per connection, supervised with simple_one_for_one strategy. Crashed connections are cleaned up automatically.",
      "server": "NoexServer",
      "httpServer": "HTTP Server",
      "supervisor": "ConnectionSupervisor",
      "connectionServer": "ConnectionServer",
      "registry": "ConnectionRegistry",
      "rateLimiter": "RateLimiter",
      "connectionIsolation": "Each WebSocket connection runs in its own GenServer — full process isolation, sequential message processing, independent subscription state and session.",
      "requestPipeline": "Request pipeline: JSON parse → Auth check → Rate limit → Route to store/rules/auth proxy → Serialize response. Push messages flow from store/rules subscriptions through the connection GenServer."
    },
    "codeExamples": {
      "title": "See It in Action",
      "subtitle": "Real examples showing server startup, client CRUD, reactive subscriptions, and transactions",
      "tabs": {
        "startup": "Server Startup",
        "crud": "Client CRUD",
        "subscriptions": "Reactive Subscriptions",
        "transactions": "Transactions"
      }
    },
    "comparison": {
      "title": "How It Compares",
      "subtitle": "noex-server vs popular real-time WebSocket solutions",
      "noexServer": "noex-server",
      "competitors": ["Socket.IO", "Supabase Realtime", "Firebase RTDB", "Ably", "Pusher"],
      "features": [
        {
          "label": "Protocol",
          "noex": "JSON over WS",
          "others": ["Custom protocol", "Postgres CDC", "Custom binary", "Custom protocol", "Custom protocol"]
        },
        {
          "label": "Per-connection Isolation",
          "noex": "GenServer actor",
          "others": ["\u2014", "\u2014", "\u2014", "\u2014", "\u2014"]
        },
        {
          "label": "Reactive Queries",
          "noex": "Convex-style subscriptions",
          "others": ["Manual rooms", "Postgres changes", "Realtime sync", "Pub/sub", "Channels"]
        },
        {
          "label": "ACID Transactions",
          "noex": "Multi-bucket over WS",
          "others": ["\u2014", "Postgres transactions", "\u2014", "\u2014", "\u2014"]
        },
        {
          "label": "Built-in Rule Engine",
          "values": [true, false, false, false, false, false]
        },
        {
          "label": "Backpressure Management",
          "noex": "Write-buffer based",
          "others": ["\u2014", "\u2014", "\u2014", "Server-side", "\u2014"]
        },
        {
          "label": "Heartbeat / Dead Conn Detection",
          "values": [true, true, true, true, true, true]
        },
        {
          "label": "Supervision Tree",
          "noex": "OTP simple_one_for_one",
          "others": ["\u2014", "\u2014", "\u2014", "\u2014", "\u2014"]
        },
        {
          "label": "Self-hosted",
          "values": [true, true, false, false, false, false]
        },
        {
          "label": "Authentication",
          "noex": "Pluggable token validation",
          "others": ["Middleware", "JWT / RLS", "Firebase Auth", "Token-based", "Token-based"]
        },
        {
          "label": "Graceful Shutdown",
          "noex": "Client notification + grace period",
          "others": ["\u2014", "Managed", "Managed", "Managed", "Managed"]
        },
        {
          "label": "Status",
          "noex": "Active",
          "others": ["Active", "Active", "Active", "Active", "Active"]
        }
      ],
      "differentiators": {
        "title": "What Makes noex-server Unique",
        "items": [
          {
            "title": "GenServer per Connection",
            "description": "Each WebSocket connection is a supervised GenServer actor. Sequential message processing eliminates race conditions, and crash isolation prevents one bad connection from affecting others."
          },
          {
            "title": "Integrated noex-store Reactivity",
            "description": "Convex-style reactive query subscriptions are proxied directly over WebSocket. Clients receive automatic push updates when underlying data changes."
          },
          {
            "title": "Built-in Rule Engine Proxy",
            "description": "The only WebSocket server with integrated rule engine access. Emit events, manage facts, and subscribe to pattern-matched rule events in real-time."
          },
          {
            "title": "Write-Buffer Backpressure",
            "description": "Protects against slow clients by monitoring WebSocket write buffer. When buffer exceeds the high water mark, push messages are safely dropped to prevent memory exhaustion."
          },
          {
            "title": "ACID Transactions over WebSocket",
            "description": "Multi-bucket atomic transactions with optimistic locking, sent as a single WebSocket message. Read-your-own-writes and automatic rollback on conflict."
          }
        ]
      }
    },
    "cta": {
      "title": "Start building real-time applications",
      "subtitle": "Add noex-server to your project in seconds",
      "install": "npm install @hamicek/noex-server",
      "copied": "Copied!",
      "github": "Star on GitHub",
      "docs": "Read the Docs",
      "backToNoex": "Back to noex"
    }
  },
  "clientPage": {
    "meta": {
      "title": "noex-client - Type-Safe Client SDK for noex Server",
      "description": "Type-safe WebSocket client with automatic reconnect, reactive subscriptions, ACID transactions, and rules engine proxy. Zero runtime dependencies."
    },
    "hero": {
      "headline": "Type-Safe Client SDK",
      "subheadline": "Fully typed WebSocket client for noex-server with automatic reconnect, subscription recovery, reactive store queries, rules engine proxy, and zero runtime dependencies.",
      "install": "npm install @hamicek/noex-client",
      "github": "View on GitHub"
    },
    "features": {
      "title": "Key Features",
      "subtitle": "Everything you need for type-safe real-time communication with noex-server",
      "typeSafe": {
        "title": "Type-Safe Bucket API",
        "description": "Generic BucketAPI<T> with full TypeScript typing. CRUD operations, queries, pagination, and aggregations — all with compile-time type safety."
      },
      "reconnect": {
        "title": "Automatic Reconnect",
        "description": "Exponential backoff with jitter, configurable parameters (maxRetries, delays, multiplier). Seamless reconnection without manual intervention."
      },
      "subscriptionRecovery": {
        "title": "Subscription Recovery",
        "description": "After reconnect, all store and rules subscriptions are automatically restored and fresh data is delivered. No manual resubscription needed."
      },
      "reactiveSubscriptions": {
        "title": "Reactive Subscriptions",
        "description": "Real-time push notifications for store queries and rules events. Initial data delivered immediately after subscription, then live updates on every change."
      },
      "transactions": {
        "title": "Transactions",
        "description": "ACID multi-bucket transactions over WebSocket. Atomic operations with optimistic locking, read-your-own-writes, and automatic rollback on conflict."
      },
      "rulesProxy": {
        "title": "Rules Engine Proxy",
        "description": "Emit events, manage facts (set/get/delete/query), and subscribe to pattern-based event streams — all through the same WebSocket connection."
      },
      "auth": {
        "title": "Authentication",
        "description": "Login, logout, and session management via token-based auth. Auto-login on connect and reconnect when auth token is provided."
      },
      "zeroDeps": {
        "title": "Zero Dependencies",
        "description": "No runtime dependencies. Works in browser natively and in Node.js with the ws package. Minimal bundle footprint."
      }
    },
    "architecture": {
      "title": "Layered Architecture",
      "subtitle": "Clean separation of concerns with four distinct layers",
      "layers": {
        "api": "API Layer",
        "apiDesc": "StoreAPI, RulesAPI, AuthAPI",
        "subscription": "Subscription Manager",
        "subscriptionDesc": "Registry, push delivery, resubscribe",
        "protocol": "Protocol Layer",
        "protocolDesc": "RequestManager + PushRouter",
        "transport": "Transport Layer",
        "transportDesc": "WebSocket, heartbeat, reconnect"
      },
      "stateMachine": "Connection State Machine",
      "states": {
        "disconnected": "disconnected",
        "connecting": "connecting",
        "connected": "connected",
        "reconnecting": "reconnecting"
      },
      "lifecycleEvents": "Lifecycle events: connected, disconnected, reconnecting, reconnected, error, welcome",
      "requestPipeline": "Request pipeline: API call → RequestManager (id correlation + timeout) → Transport (WebSocket send) → Response routing"
    },
    "codeExamples": {
      "title": "See It in Action",
      "subtitle": "Real code examples showing connection, CRUD, subscriptions, transactions, and rules",
      "tabs": {
        "connection": "Connection",
        "crud": "CRUD Operations",
        "subscriptions": "Subscriptions",
        "transactions": "Transactions",
        "rules": "Rules"
      }
    },
    "reconnect": {
      "title": "Reconnect Behavior",
      "subtitle": "Automatic reconnection with exponential backoff, jitter, and full subscription recovery",
      "backoffTitle": "Exponential Backoff",
      "attempts": [
        { "attempt": 1, "delay": "~1s", "formula": "1000ms + jitter" },
        { "attempt": 2, "delay": "~2s", "formula": "2000ms + jitter" },
        { "attempt": 3, "delay": "~4s", "formula": "4000ms + jitter" },
        { "attempt": 4, "delay": "~8s", "formula": "8000ms + jitter" },
        { "attempt": 5, "delay": "~16s", "formula": "16000ms + jitter" },
        { "attempt": "N", "delay": "max 30s", "formula": "capped at maxDelayMs" }
      ],
      "configTitle": "Configuration",
      "configParams": [
        { "name": "maxRetries", "default": "Infinity", "description": "Maximum reconnect attempts" },
        { "name": "initialDelayMs", "default": "1000", "description": "Base delay before first retry" },
        { "name": "maxDelayMs", "default": "30000", "description": "Maximum delay cap" },
        { "name": "backoffMultiplier", "default": "2", "description": "Exponential multiplier" },
        { "name": "jitterMs", "default": "500", "description": "Random jitter added to delay" }
      ],
      "recoveryTitle": "Subscription Recovery Flow",
      "recoverySteps": ["Reconnect", "Re-authenticate", "Resubscribe all", "Deliver fresh data"],
      "disableNote": "Disable reconnect with reconnect: false"
    },
    "comparison": {
      "title": "How It Compares",
      "subtitle": "noex-client vs popular real-time client SDKs",
      "noexClient": "noex-client",
      "competitors": ["Socket.IO Client", "Supabase JS", "Firebase JS", "Ably Realtime"],
      "features": [
        {
          "label": "Type-Safe Generic API",
          "noex": "BucketAPI<T>",
          "others": ["\u2014", "Generated types", "Untyped", "\u2014"]
        },
        {
          "label": "Auto Subscription Recovery",
          "values": [true, false, false, true, true]
        },
        {
          "label": "ACID Transactions",
          "noex": "Multi-bucket over WS",
          "others": ["\u2014", "Postgres transactions", "\u2014", "\u2014"]
        },
        {
          "label": "Rules Engine Proxy",
          "values": [true, false, false, false, false]
        },
        {
          "label": "Reconnect with Backoff",
          "values": [true, true, true, true, true]
        },
        {
          "label": "Auto-login on Reconnect",
          "values": [true, false, false, true, false]
        },
        {
          "label": "Reactive Query Subscriptions",
          "noex": "Convex-style push",
          "others": ["Manual rooms", "Postgres changes", "Realtime sync", "Pub/sub"]
        },
        {
          "label": "Facts Management",
          "noex": "Set/get/delete/query",
          "others": ["\u2014", "\u2014", "\u2014", "\u2014"]
        },
        {
          "label": "Runtime Dependencies",
          "noex": "Zero",
          "others": ["engine.io-client +", "Multiple", "Multiple", "Multiple"]
        },
        {
          "label": "Browser + Node.js",
          "values": [true, true, true, true, true]
        },
        {
          "label": "Status",
          "noex": "Active",
          "others": ["Active", "Active", "Active", "Active"]
        }
      ],
      "differentiators": {
        "title": "What Makes noex-client Unique",
        "items": [
          {
            "title": "Type-Safe Generic API",
            "description": "BucketAPI<T> gives you compile-time type safety on every CRUD operation, query, and aggregation. No more runtime type mismatches."
          },
          {
            "title": "Automatic Subscription Recovery",
            "description": "On reconnect, all active store and rules subscriptions are automatically restored. Fresh data is delivered without any manual resubscription logic."
          },
          {
            "title": "Integrated Rules Engine",
            "description": "The only client SDK with built-in rules engine access. Emit events, manage facts, and subscribe to pattern-matched rule events over the same connection."
          },
          {
            "title": "ACID Transactions over WebSocket",
            "description": "Multi-bucket atomic transactions with optimistic locking, sent as a single message. Read-your-own-writes and automatic rollback on conflict."
          },
          {
            "title": "Zero Runtime Dependencies",
            "description": "No transitive dependencies to audit or update. Works natively in browsers, and in Node.js with just the ws package as a peer dependency."
          }
        ]
      }
    },
    "cta": {
      "title": "Start building type-safe real-time apps",
      "subtitle": "Add noex-client to your project in seconds",
      "install": "npm install @hamicek/noex-client",
      "copied": "Copied!",
      "github": "Star on GitHub",
      "docs": "Read the Docs",
      "backToNoex": "Back to noex",
      "peerNote": "Requires a running noex-server. In Node.js, install ws as a peer dependency."
    }
  }
}
